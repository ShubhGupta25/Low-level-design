Bullets: 
-> Single Responsibility -> Try to create classes with single responsibilities.
-> Open/Close (can be extended, not not be modified) -> Create abstract methods, instead of overridden methods.
-> LisKov Substitution (Any impl can be called) -> Use Interface/Super class references.
-> Interface segregation -> If interface does mutiple thigs, saperte them, so user can have only specific required action while using.
-> Dependency Inversion -> Service class will take the required implementation class object in the reference. and just cakk the methods using that.

## Summary Table

| Principle | When to Use                         | How to Use                                  | Advantages         | Disadvantages     |
| --------- | ----------------------------------- | ------------------------------------------- | ------------------ | ----------------- |
| SRP       | Class has multiple responsibilities | Refactor into single-responsibility classes | Easier maintenance | More classes      |
| OCP       | Anticipate future changes           | Use abstraction, inheritance                | Flexible, reusable | More abstractions |
| LSP       | Using inheritance                   | Ensure substitutability                     | Reliable code      | Hard to enforce   |
| ISP       | Large interfaces                    | Split into smaller interfaces               | Flexible, clear    | More interfaces   |
| DIP       | Tight coupling                      | Depend on abstractions                      | Loose coupling     | More boilerplate  |

---


# SOLID Principles in Low Level Design (LLD)

## Overview

SOLID is an acronym for five design principles intended to make software designs more understandable, flexible, and maintainable. These principles are widely used in object-oriented design and are fundamental for building robust systems.

---

## 1. Single Responsibility Principle (SRP)

- **Definition:** A class should have only one reason to change, meaning it should have only one job or responsibility.
- **When to Use:** When a class is doing too many unrelated tasks or has multiple reasons to change.
- **How to Use:** Refactor classes so each handles a single responsibility. Extract unrelated logic into separate classes.
- **Advantages:** Easier to maintain, test, and understand. Reduces risk of bugs when making changes.
- **Disadvantages:** May lead to more classes, increasing codebase size.

---

## 2. Open/Closed Principle (OCP)

- **Definition:** Software entities (classes, modules, functions) should be open for extension but closed for modification.
- **When to Use:** When you anticipate changes or new features in the future.
- **How to Use:** Use interfaces, abstract classes, and polymorphism to allow new functionality without altering existing code.
- **Advantages:** Promotes code reusability and flexibility. Reduces risk of breaking existing code.
- **Disadvantages:** Can introduce complexity with too many abstractions.

---

## 3. Liskov Substitution Principle (LSP)

- **Definition:** Subtypes must be substitutable for their base types without altering the correctness of the program.
- **When to Use:** When creating class hierarchies and inheritance structures.
- **How to Use:** Ensure derived classes extend base classes without changing expected behavior. Avoid overriding methods in a way that breaks contracts.
- **Advantages:** Ensures reliability and predictability in code using polymorphism.
- **Disadvantages:** Can be hard to enforce; violations may not be obvious.

---

## 4. Interface Segregation Principle (ISP)

- **Definition:** No client should be forced to depend on methods it does not use.
- **When to Use:** When interfaces/classes have too many methods, and clients only use a subset.
- **How to Use:** Split large interfaces into smaller, more specific ones.
- **Advantages:** Increases code clarity and flexibility. Reduces side effects from changes.
- **Disadvantages:** May result in more interfaces, increasing codebase size.

---

## 5. Dependency Inversion Principle (DIP)

- **Definition:** High-level modules should not depend on low-level modules; both should depend on abstractions.
- **When to Use:** When high-level logic is tightly coupled to low-level details.
- **How to Use:** Depend on interfaces or abstract classes, not concrete implementations. Use dependency injection.
- **Advantages:** Promotes loose coupling, easier testing, and flexibility.
- **Disadvantages:** Can add complexity and require more boilerplate code.

---

# SOLID Principles - Simple Example (Java)

Suppose you are building a notification system. Here is how each SOLID principle can be applied:

## 1. Single Responsibility Principle (SRP)

```java
// Handles only email sending
public class EmailSender {
    public void sendEmail(String message, String recipient) {
        // logic to send email
    }
}
```

## 2. Open/Closed Principle (OCP)

```java
// Notification interface
public interface Notification {
    void send(String message, String recipient);
}

// Email notification
public class EmailNotification implements Notification {
    public void send(String message, String recipient) {
        // send email
    }
}

// SMS notification (added later, no change to existing code)
public class SMSNotification implements Notification {
    public void send(String message, String recipient) {
        // send SMS
    }
}
```

## 3. Liskov Substitution Principle (LSP)

```java
public void notifyUser(Notification notification, String message, String recipient) {
    notification.send(message, recipient); // works for any Notification subtype
}
```

## 4. Interface Segregation Principle (ISP)

```java
// Instead of one big interface, use small ones
public interface EmailSender {
    void sendEmail(String message, String recipient);
}
public interface SMSSender {
    void sendSMS(String message, String recipient);
}
```

## 5. Dependency Inversion Principle (DIP)

```java
public class NotificationService {
    private Notification notification;
    public NotificationService(Notification notification) {
        this.notification = notification;
    }
    public void notify(String message, String recipient) {
        notification.send(message, recipient);
    }
}
```

---

**Summary:**

- Each class or interface has a single responsibility (SRP).
- New notification types can be added without modifying existing code (OCP).
- All notification types can be used interchangeably (LSP).
- Clients depend only on the methods they use (ISP).
- High-level modules depend on abstractions, not concrete classes (DIP).
