/**
 * Design Pizza billing system using Decorator Pattern
 * 
 * Pizza can have multiple toppings, each added dynamically.
 */

// Component interface
interface Pizza {
    Integer billAmount();
}

// Concrete component
@Builder
@Getter
class Margherita implements Pizza {
    private Integer amount = 100;

    @Override
    public Integer billAmount() {
        return amount;
    }
}

// Abstract decorator
@Getter
abstract class PizzaToppings implements Pizza {
    private Pizza pizza;

    PizzaToppings(Pizza pizza) {
        this.pizza = pizza;
    }
}

// Concrete decorator for Olive topping
class OliveTopping extends PizzaToppings {
    private Integer toppingPrice = 50;

    OliveTopping(Pizza pizza) {
        super(pizza);
    }

    @Override
    public Integer billAmount() {
        // Add topping price to the wrapped pizza's bill
        return pizza.billAmount() + toppingPrice;
    }
}

// Billing system to manage orders
class PizzaBillingSystem {
    List<Pizza> orders;

    @Builder
    PizzaBillingSystem() {
        orders = new ArrayList<>();
    }

    public void addToCart(Pizza order) {
        orders.add(order);
    }

    public Integer totalAmount() {
        Integer billedAmount = 0;
        for (Pizza order : orders) {
            billedAmount += order.billAmount(); // Sum all orders
        }
        return billedAmount;
    }
}

// Main class to demonstrate usage
public class Solution {
    public static void main(String[] args) {
        Pizza order1 = Margherita.builder().build();
        Pizza order2 = Margherita.builder().build();

        // Customizing order2 with Olive topping
        order2 = new OliveTopping(order2);

        PizzaBillingSystem counter = PizzaBillingSystem.builder().build();
        counter.addToCart(order1);
        counter.addToCart(order2);

        System.out.println(counter.totalAmount()); // Print total bill
    }
}

