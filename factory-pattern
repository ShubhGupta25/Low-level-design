# Factory Pattern in Low Level Design (LLD)

-> Factory pattern is where we have centralized factory class to create object based on input given by the user.

## What is the Factory Pattern?
The Factory Pattern is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. It helps in encapsulating the object creation logic.

---

## When to Use
- When the exact type of object to create is determined at runtime.
- When you want to decouple object creation from its usage.
- When you have a family of related objects and want to centralize their creation.

---

## How to Use
1. Define a common interface or abstract class for the objects to be created.
2. Implement concrete classes for each object type.
3. Create a Factory class with a method that returns objects based on input or configuration.

---

## Example (Java)
Suppose you want to create different types of notifications (Email, SMS):

```java
// Product interface
public interface Notification {
    void notifyUser();
}

// Concrete products
public class EmailNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending Email Notification");
    }
}

public class SMSNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending SMS Notification");
    }
}

// Factory class
public class NotificationFactory {
    public static Notification createNotification(String type) {
        if (type.equalsIgnoreCase("EMAIL")) {
            return new EmailNotification();
        } else if (type.equalsIgnoreCase("SMS")) {
            return new SMSNotification();
        }
        throw new IllegalArgumentException("Unknown notification type");
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        Notification notification = NotificationFactory.createNotification("EMAIL");
        notification.notifyUser();
    }
}
```

---

## Advantages
- Encapsulates object creation logic.
- Promotes loose coupling between client and concrete classes.
- Makes code more flexible and maintainable.

---

## Disadvantages
- Can introduce extra classes and complexity.
- May be less efficient if used for simple object creation.

---
