# Strategy Pattern in Low Level Design (LLD)

## What is the Strategy Pattern?

The Strategy Pattern is a behavioral design pattern that enables selecting an algorithmâ€™s behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. The pattern lets the algorithm vary independently from clients that use it.

---

## When to Use

- When you have multiple ways of performing an operation (e.g., different sorting or payment methods).
- When you want to avoid using many conditional statements to select behaviors.
- When you want to make your code more flexible and extensible.

---

## How to Use

1. Define a common interface for all supported algorithms (strategies).
2. Implement concrete strategy classes for each algorithm.
3. The context class maintains a reference to a strategy object and delegates the work to it.
4. The client can change the strategy at runtime.

---

## Example (Java)

Suppose you want to implement a payment system that supports multiple payment methods:

```java
// Strategy interface
public interface PaymentStrategy {
    void pay(int amount);
}

// Concrete strategies
public class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card.");
    }
}

public class PayPalPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal.");
    }
}

// Context
public class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.setPaymentStrategy(new CreditCardPayment());
        cart.checkout(100);

        cart.setPaymentStrategy(new PayPalPayment());
        cart.checkout(200);
    }
}
```

---

## Advantages

- Promotes the Open/Closed Principle (easy to add new strategies without changing existing code).
- Eliminates complex conditional statements.
- Strategies can be changed at runtime.

---

## Disadvantages

- Increases the number of classes.
- The client must be aware of different strategies.

---

Example for PaymentSystem:

CreditAllocationType -> Have all the types of credit allocation strategies, and the method to get that strategy

CreditAllocationStrategy -> Interface for credit allocation strategies

CreditCardCreditAllocationStrategy -> Concrete implementation for credit card allocation

PayPalCreditAllocationStrategy -> Concrete implementation for PayPal allocation

CreditAllocationService -> Context class that uses the strategy

CreditAllocationServiceImpl -> Implementation of the context class

One of the extention to it in terms of usability
--------------

This type of enum implementation we can use, where strategy type will be coming from the client and based on the type we will get the stategy object from the enum and will use it for further processing.

enum CreditAllocationType {
  PAYPAL {
    public CreditAllocationStrategy get(int x, int y, int z) {
      return new PaypalCredtiAllocationStrategy(x, y);
    }
  }

  CREDIT_CARD {
    public CreditAllocationStrategy get(int x, int y, int z) {
      return new CreditCardCreditAllocationStrategy(y, z);
    }
  }

  public CreditAllocationStrategy get(int x, int y, int z);
}