/**
 * Designing Snake and Ladder game using Abstract Factory Pattern
 *
 * Abstract Factory Pattern is used to create families of related objects (Board, Dice, Rule)
 * for different game variants (Classic, Custom, Tournament) without specifying their concrete classes.
 */

// Product interface for Board
interface Board {}

// Classic Board implementation
@Builder
class ClassicBoard implements Board {
    private int snakes = 10;
    private int ladders = 10;
    // ...additional logic if needed
}

// Custom Board implementation
class CustomBoard implements Board {
    private int snakes;
    private int ladders;

    @Builder
    CustomBoard(int snakes, int ladders) {
        this.snakes = snakes;
        this.ladders = ladders;
    }
}

// Themed Board implementation
@Builder
class ThemedBoard implements Board {
    private int snakes = 16;
    private int ladders = 25;
    // ...additional logic if needed
}

// Product interface for Dice
interface Dice {
    int rollANumber();
}

// Regular Dice implementation
@Builder
class RegularDice implements Dice {
    private int sides = 6;
    public int rollANumber() {
        return (int)(Math.random() * sides) + 1;
    }
}

// Loaded Dice implementation
@Builder
class LoadedDice implements Dice {
    private int sides = 12;
    public int rollANumber() {
        return (int)(Math.random() * sides) + 1;
    }
}

// Custom Dice implementation
class CustomDice implements Dice {
    private int sides;
    @Builder
    CustomDice(int sides) {
        this.sides = sides;
    }
    public int rollANumber() {
        return (int)(Math.random() * sides) + 1;
    }
}

// Product interface for Rule
interface Rule {
    Map<State, Action> gameRules();
}

// Classic Rule implementation
class ClassicRule implements Rule {
    private Map<State, Action> rules = new HashMap<>();
    @Builder
    ClassicRule() {
        // Initialize classic rules
    }
    public Map<State, Action> gameRules() { return rules; }
}

// Custom Rule implementation
class CustomRule implements Rule {
    private Map<State, Action> rules;
    @Builder
    CustomRule(Map<State, Action> rules) {
        this.rules = rules;
    }
    public Map<State, Action> gameRules() { return rules; }
}

// Tournament Rule implementation
class TournamentRule implements Rule {
    private Map<State, Action> rules = new HashMap<>();
    @Builder
    TournamentRule() {
        // Initialize tournament rules
    }
    public Map<State, Action> gameRules() { return rules; }
}

// Abstract Factory interface
interface GameFactory {
    Board setupBoard();
    Rule setupRules();
    Dice setupDice();
}

// Classic Game Factory
@Builder
class ClassicGameFactory implements GameFactory {
    public Board setupBoard() { return ClassicBoard.builder().build(); }
    public Dice setupDice() { return RegularDice.builder().build(); }
    public Rule setupRules() { return ClassicRule.builder().build(); }
}

// Custom Game Factory
class CustomGameFactory implements GameFactory {
    private int snakes;
    private int ladders;
    private int sides;
    private Map<State, Action> rules;
    @Builder
    CustomGameFactory(int snakes, int ladders, int sides, Map<State, Action> rules) {
        this.snakes = snakes;
        this.ladders = ladders;
        this.sides = sides;
        this.rules = rules;
    }
    public Board setupBoard() { return CustomBoard.builder().snakes(snakes).ladders(ladders).build(); }
    public Dice setupDice() { return CustomDice.builder().sides(sides).build(); }
    public Rule setupRules() { return CustomRule.builder().rules(rules).build(); }
}

// Tournament Game Factory
@Builder
class TournamentGameFactory implements GameFactory {
    public Board setupBoard() { return ThemedBoard.builder().build(); }
    public Dice setupDice() { return LoadedDice.builder().build(); }
    public Rule setupRules() { return TournamentRule.builder().build(); }
}

// GameBroker uses the abstract factory to set up the game
class GameBroker {
    private Rule rules;
    private Board board;
    private Dice dice;
    @Builder
    GameBroker(GameFactory gameFactory) {
        board = gameFactory.setupBoard();
        rules = gameFactory.setupRules();
        dice = gameFactory.setupDice();
    }
    // Additional methods to play the game can be added here
}

// Main class to demonstrate usage
public class Solution {
    public static void main(String[] args) {
        GameFactory gameFactory = ClassicGameFactory.builder().build();
        GameBroker gameBroker = GameBroker.builder().gameFactory(gameFactory).build();
        // gameBroker can now be used to play the game with the selected variant
    }
}

enum State {
    IF_ON_SNAKE,
    IF_ON_LADDER,
    IF_ON_BOTH_SNAKE_LADDER;
}

enum Action {
    GO_TO_END_OF_SNAKE,
    GO_UP_THE_LADDER;
}