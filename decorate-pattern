# Decorator Pattern in Low Level Design (LLD)

## What is the Decorator Pattern?

The Decorator Pattern is a structural design pattern that allows you to add new functionality to objects dynamically without altering their structure. It wraps the original object in a decorator class that adds new behaviors or responsibilities.

---

## When to Use

- When you want to add responsibilities to individual objects, not to an entire class.
- When extension by subclassing is impractical or leads to too many subclasses.
- When you need to add features dynamically at runtime.

---

## How to Use

1. Define a common interface for both the core component and decorators.
2. Create concrete component classes implementing the interface.
3. Create abstract decorator class implementing the same interface and holding a reference to a component.
4. Concrete decorators extend the abstract decorator and add new behavior.

---

## Example (Java)

Suppose you want to build a pizza ordering system where you can add toppings dynamically:

```java
// Component interface
public interface Pizza {
    String getDescription();
    double getCost();
}

// Concrete component
public class Margherita implements Pizza {
    public String getDescription() { return "Margherita"; }
    public double getCost() { return 100; }
}

// Abstract decorator
public abstract class PizzaDecorator implements Pizza {
    protected Pizza pizza;
    public PizzaDecorator(Pizza pizza) { this.pizza = pizza; }
}

// Concrete decorators
public class Cheese extends PizzaDecorator {
    public Cheese(Pizza pizza) { super(pizza); }
    public String getDescription() { return pizza.getDescription() + ", Cheese"; }
    public double getCost() { return pizza.getCost() + 20; }
}

public class Olives extends PizzaDecorator {
    public Olives(Pizza pizza) { super(pizza); }
    public String getDescription() { return pizza.getDescription() + ", Olives"; }
    public double getCost() { return pizza.getCost() + 15; }
}

// Usage
public class Main {
    public static void main(String[] args) {
        Pizza pizza = new Margherita();
        pizza = new Cheese(pizza); // add cheese
        pizza = new Olives(pizza); // add olives
        System.out.println(pizza.getDescription() + ": " + pizza.getCost());
    }
}
```

---

## Advantages

- Add new functionality without modifying existing code (Open/Closed Principle).
- More flexible than inheritance for extending behavior.
- Can add or remove features at runtime.

---

## Disadvantages

- Can result in many small classes.
- Complexity increases as the number of decorators grows.
- Debugging can be harder due to many layers of wrapping.

---
